R4.1: npm Monorepo Tooling and Zero-Dependency Architecture
MISSION ID: R4.1_npm-monorepo-research STATUS: COMPLETE DATE: 2025-09-15 PREPARED BY: Principal JavaScript Architect, Build Systems & CI FOR: Technical Lead, Mission B4.2

I. Executive Summary & Recommendation
This report provides a comprehensive analysis of the 2025 npm monorepo tooling landscape to determine the optimal solution for the Cross-Protocol Manifest System (CPMS). The primary objective is to select a tooling stack that enables a modular, multi-package release to the public npm registry while strictly adhering to the project's core "zero-dependency" philosophy and sub-10KB bundle size targets.

Primary Recommendation: The optimal strategy for the CPMS is not a single "all-in-one" framework but a "best-of-breed" stack, assembled from four distinct, best-in-class tools.

Foundation (Package Manager): pnpm workspaces

Orchestration (Task Runner): Turborepo

Bundling (Build System): tsup (leveraging esbuild)

Publishing (Version Management): Changesets

Rationale Summary: This layered stack is recommended over monolithic solutions (such as Nx) because it provides maximum flexibility, superior performance, and a clear, uncompromised technical path to achieving the project's critical zero-dependency constraint.

pnpm workspaces is non-negotiable as the foundation. Its strict, non-flat node_modules structure is the only solution that prevents "phantom dependencies" at the development level, enforcing the project's dependency boundaries.   

Turborepo provides elite, simple-to-configure task orchestration and remote caching. It layers perfectly on top of pnpm without the high-complexity overhead of alternative frameworks.   

tsup is the linchpin of the zero-dependency architecture. It is a modern bundler designed for libraries that, by default, inlines devDependencies. This allows the creation of internal shared utility packages that are bundled at build time, resulting in published packages with zero runtime dependencies.   

Changesets provides the safest, most robust, and CI-native workflow for managing independent versioning and publishing, using a "Release PR" model that is superior to command-line-based publishing tools.   

Actionable Summary for Mission B4.2: Implementation will proceed by adopting a scoped package structure (packages/ for published protocols, internal/ for shared utilities). The build pipeline will use tsup to compile each package into tree-shakable CJS and ESM modules. A GitHub Actions workflow will use Changesets to manage all npm publications, and a CI gate will be implemented to automatically fail any build that attempts to introduce a runtime dependency into a public package.

II. Monorepo Tooling Decision Framework (2025 Landscape)
The analysis to select the optimal tooling stack is not a flat comparison of five equivalent tools. The 2025 monorepo landscape has bifurcated into two distinct philosophies: "All-in-One Frameworks" and "Layered Stacks."

All-in-One Frameworks (e.g., Nx): These tools, such as Nx, provide a comprehensive, integrated, and highly opinionated solution. They manage everything from code generation and plugins to task running and publishing. Lerna, now maintained by Nx, has been absorbed into this philosophy and uses nx.json for its core task-running capabilities. While powerful, these frameworks have a "steeper learning curve"  and can create friction when project constraints (like zero-dependency) deviate from the framework's standard assumptions.   

Layered Stacks (e.g., Turborepo + pnpm): This approach composes a stack from specialized, best-in-class tools. pnpm workspaces provides the foundation, Turborepo provides task running, and Changesets provides publishing. Turborepo is explicitly designed as a high-performance task runner that layers on top of an existing package manager's workspace implementation.   

Given the project's unique and non-negotiable zero-dependency constraint, the "Layered Stack" approach is the superior choice. It avoids framework lock-in and allows for the precise assembly of tools required to meet the objective.

The decision process is therefore sequential: (1) Select the Foundation, (2) Select the Orchestrator, and (3) Select the Publishing mechanism.

1. Foundation: pnpm workspaces vs. npm workspaces
The package manager's workspace implementation is the foundation of the monorepo. It handles dependency installation and the linking of internal packages.

npm workspaces: This is the standard, built-in solution. It provides basic symlinking and a way to run scripts across packages. Its primary and problematic characteristic is its "flat" node_modules hoisting structure. This structure can lead to "phantom dependencies," where a package (@cpms/core) can successfully import a library that was only installed as a dependency of a sibling package (@cpms/data). This behavior encourages sloppy dependency management and is a direct threat to the zero-dependency philosophy.   

pnpm workspaces: This solution is rapidly becoming the industry standard for serious monorepos. It uses a content-addressable store with hard links and a "non-flat node_modules structure". This architecture is "strict" : a package is only able to access the dependencies that are explicitly declared in its own package.json file. It is physically impossible to access a phantom dependency.   

Recommendation: pnpm workspaces is the non-negotiable choice. Its strict dependency enforcement  is the only solution that aligns with the project's zero-dependency philosophy at the development level. The superior performance and disk-space efficiency are secondary, albeit significant, benefits.   

2. Orchestration (Task Runner): Turborepo vs. Nx vs. Lerna (v9+)
The orchestrator is responsible for running tasks (like build, test, lint) across the monorepo, providing caching, and understanding the dependency graph to only run tasks on "affected" packages.

Lerna (v9+): Lerna is now "powered by Nx" and effectively a "Lerna-flavored" frontend for Nx's task runner. It relies on nx.json for task definitions. For a new project, selecting modern Lerna is functionally equivalent to selecting Nx.   

Nx: Nx is a powerful, "comprehensive" solution. Its primary value-add is a sophisticated plugin ecosystem, advanced code generation, and powerful graph-based "affected" commands. However, this power comes with significant configuration complexity and a steep learning curve.   

Turborepo: Turborepo is a "high-performance build system"  that focuses only on task running and caching. It is "simple" , "easy to get started with" , and provides exceptional performance with its Remote Caching feature. Its "affected" logic is also a core, simple-to-use feature.   

Recommendation: Turborepo is the optimal choice for orchestration. The CPMS project consists of simple, zero-dependency libraries; it does not require Nx's complex plugin ecosystem or code generation. The primary requirement is raw build speed and effective caching. Turborepo provides 99% of the required value (caching, "affected" graph) with 10% of Nx's complexity. Its simple turbo.json configuration  is vastly simpler to maintain.   

3. Publishing (Version Management): Changesets vs. Lerna/Nx Release
The publishing tool manages package versioning (especially independent versioning) and the physical publication to the npm registry.

Lerna/Nx Publishing: Both tools support independent versioning ("version": "independent" in Lerna ; "projectsRelationship": "independent" in Nx ). The workflow is command-based: a developer or CI job runs lerna publish  or nx release. This single, monolithic command calculates changes since the last git tag, prompts for versions (or infers them), and publishes in one operation. This workflow is fragile; if a publish fails halfway, git tags and package versions can become desynchronized from the registry, requiring manual, high-risk intervention.   

Changesets: This tool, recommended in pnpm's documentation as an alternative to Lerna , is not a single command but a workflow.   

A developer runs pnpm changeset add and commits a simple .md file describing their "intent to release".   

In CI, the changesets/action  aggregates all pending "intent" files and opens a "Release PR" that contains all calculated version bumps and CHANGELOG.md updates.   

The team reviews, approves, and merges this "Release PR" just like any other code.

Merging this PR triggers the final changeset publish  or pnpm -r publish  command, which publishes only the packages whose versions were bumped in the Release PR.   

Recommendation: Changesets provides the most scalable, automatable, and error-resilient workflow for independent package publishing. The decoupled, "Release PR"  model is fundamentally safer and more auditable than the monolithic command-based approach of Lerna and Nx.   

Decision Matrix
This matrix summarizes the analysis of the recommended stack and its alternatives.

Table 1: Monorepo Tooling Decision Matrix

Criteria	pnpm workspaces (Rec.)	npm workspaces	Turborepo (Rec.)	Nx	Changesets (Rec.)	Lerna v9+ / Nx Release
Primary Role	Foundation (Manager)	Foundation (Manager)	Orchestration (Runner)	Orchestration (Framework)	Publishing (Workflow)	Publishing (Command)
Zero-Dep Compatibility	
Excellent. Strict node_modules  prevents phantom dependencies.

Poor. Flat node_modules  encourages phantom dependencies.

Excellent. Tool-agnostic. Caches any script.	Good. Can be configured, but plugins may add dependencies.	Excellent. A-gnostic, manages versioning metadata.	Good. Can be configured to publish zero-dep packages.
Linking Strategy	
Symlinks + Hard links. Non-flat node_modules.

Symlinks. Flat node_modules.

N/A (Uses Foundation)	N/A (Uses Foundation)	N/A	N/A
Build Caching	N/A	N/A	
Excellent. Simple, fast, remote-cache-first.

Excellent. Powerful, "computed" caching, but more complex.

N/A	N/A
CI "Affected" Logic	N/A	N/A	
Excellent. turbo run... --filter.

Excellent. nx affected.

N/A	N/A
Publishing Workflow	
N/A (Has pnpm publish )

N/A	N/A	
Integrated (nx release). Monolithic.

Excellent. Decoupled, Git-based, PR-driven.

Integrated (lerna publish). Monolithic.

Learning Curve	Low	Low	
Very Low 

High 

Low-to-Medium	Medium
  
III. Implementation Blueprint: Package & Build Architecture
This section provides the actionable specifications for package structure, shared code, and build configuration required for Mission B4.2.

1. Package Structure Specification
The monorepo will adopt a scoped structure that clearly segregates publicly-published packages from internal, non-published tooling.

/ (root)
├──.github/workflows/
│   ├── ci.yml         # PR validation (build, test, lint, size-check)
│   └── release.yml    # Main branch (Changeset Release PR, Publish)
├── internal/
│   ├── utils/         # @cpms/utils (shared code, devDependency only)
│   ├── eslint-config/ # @cpms/eslint-config (dev tool)
│   └── tsconfig/      # @cpms/tsconfig (shared TS base config)
├── packages/
│   ├── core/          # @cpms/core (published to npm)
│   ├── data/          # @cpms/data (published to npm)
│   └── event/         # @cpms/event (published to npm)
├──.changeset/        # Changesets configuration and.md files
├── pnpm-workspace.yaml
├── turbo.json
└── package.json       # Root package.json (private: true)
The pnpm-workspace.yaml file at the root will define this structure :   

YAML
packages:
  - 'packages/*'
  - 'internal/*'
2. The Zero-Dependency Shared Code Strategy
This architecture is the solution to sharing code (like utils.js) while adhering to the zero-dependency mandate. The strategy is to treat shared code as a build-time devDependency and use a bundler (tsup) to inline that code into the final published package.

This approach avoids brittle file-copying scripts  and, most importantly, avoids adding a runtime dependency  that would violate the project's core constraint.   

Step-by-Step Workflow:

Creation: The internal/utils package is created with its own package.json, defining its name as "@cpms/utils".

Installation: A consuming package (e.g., packages/core) installs this utility as a devDependency:

Bash
pnpm add @cpms/utils --filter @cpms/core --save-dev
Local State: The packages/core/package.json now lists "@cpms/utils": "workspace:*" under devDependencies. pnpm symlinks this package locally.

Bundling: The packages/core package uses tsup as its bundler.   

Build Execution: When turbo run build --filter @cpms/core is executed, tsup builds @cpms/core. It encounters import { sharedFunction } from '@cpms/utils' in the source code.

Inlining: tsup's underlying philosophy (and that of esbuild) is that devDependencies are build-time tools, and their code should be inlined into the final bundle. It resolves the code from @cpms/utils and bundles it directly into the output files (e.g., dist/index.js and dist/index.mjs) of @cpms/core.   

Final Result: The published @cpms/core package on npm contains the necessary utility code but has zero entries in its dependencies block. The zero-dependency constraint is successfully met.

3. Package-Level Build Specification (<10KB & Tree-Shaking)
To ensure minimal bundle sizes and compatibility with modern bundlers, every package in the packages/ directory will adhere to the following tsup and package.json configuration.

tsup.config.ts Template: Each package will have this file at its root. tsup is a minimal-config, fast bundler based on esbuild, ideal for libraries.   

TypeScript
// packages/core/tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],     // Package entry point
  format: ['cjs', 'esm'],        // Build for both CJS and ESM [7, 41]
  dts: true,                     // Generate.d.ts files
  splitting: true,               // Enable code splitting for shared helpers
  clean: true,                   // Clean 'dist' folder before build
  treeshake: true,               // Enable tree-shaking
  minify: true,                  // Minify output
  
  // By default, tsup bundles all devDependencies (like @cpms/utils)
  // and marks 'dependencies' and 'peerDependencies' as external.
  // Since we have zero dependencies, this configuration is perfect.
});
package.json Template: This structure is critical for enabling tree-shaking and modern module resolution.   

JSON
// packages/core/package.json
{
  "name": "@cpms/core",
  "version": "1.0.0",
  "private": false,
  "description": "Core protocol for CPMS.",
  "type": "module",
  "sideEffects": false,
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "lint": "eslint.",
    "check-size": "monosize --threshold 10kb"
  },
  "dependencies": {
    "//": "This block MUST be empty."
  },
  "devDependencies": {
    "@cpms/tsconfig": "workspace:*",
    "@cpms/utils": "workspace:*",
    "eslint": "...",
    "tsup": "...",
    "typescript": "...",
    "monosize": "..."
  }
}
Key Configuration Rationale:

"type": "module": This field is essential for modern ESM support.   

"sideEffects": false": This is a critical hint for bundlers like Webpack and Rollup. It declares that no file in this package has side effects, allowing end-users to safely tree-shake any unused exports.   

"exports": This map is the modern standard for defining module entry points, ensuring correct CJS/ESM resolution.   

"check-size" script: This script uses a tool like monosize  to enforce the <10KB constraint in CI.   

IV. Workflow Design: Local Development, CI, and Publishing
This section details the day-to-day commands and automated CI/CD pipelines for the recommended stack.

1. Local Development Workflow
The local development experience must be smooth, fast, and accurately reflect the CI environment.   

Initial Setup: A developer runs pnpm install once at the root. pnpm reads the pnpm-workspace.yaml and symlinks all internal packages (e.g., @cpms/utils becomes available to @cpms/core).   

Running Tasks: All commands are run from the monorepo root using the turbo binary.

Build everything: turbo run build

Develop (watch) a single package: turbo run dev --filter=@cpms/core

Build a package and its dependencies: turbo run build --filter=@cpms/data (This will first build @cpms/utils if it has changed, cache it, and then build @cpms/data).   

Run tests: turbo run test (Turborepo pulls from cache for all packages with no changes).   

Changes made to internal/utils are immediately picked up by the tsup --watch process running for @cpms/core, as pnpm has linked them. This provides a seamless, fast feedback loop.

2. CI/CD Build Pipeline Specification (GitHub Actions)
This pipeline runs on every Pull Request. Its goal is to validate all affected packages, enforce constraints, and block merging if any checks fail.

.github/workflows/ci.yml

YAML
name: CI Validation

on:
  pull_request:
    branches: [main]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # **CRITICAL** for Turborepo 'affected' [25]

      - name: Use pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm' # Cache pnpm dependencies

      - name: Install dependencies
        run: pnpm install

      - name: Setup Turborepo Caching
        # This action configures GitHub's cache for use with Turborepo
        uses: dtinth/setup-github-actions-caching-for-turbo@v1 [50]

      - name: Build Affected Packages
        # Use Turborepo 'affected' syntax to compare PR head to main 
        run: turbo run build --filter="...[origin/main]"

      - name: Lint Affected Packages
        run: turbo run lint --filter="...[origin/main]"

      - name: Test Affected Packages
        run: turbo run test --filter="...[origin/main]"

      - name: Check for Zero-Dependencies (CI Gate)
        # **CRITICAL** constraint enforcement.
        run: |
          if [ -n "$(find packages -name package.json -print0 | xargs -0 -I {} sh -c 'jq ".dependencies | select(.) | select(length > 0)" {}')" ]; then
            echo "::error:: Found packages in 'packages/' with runtime 'dependencies'."
            echo "All published packages must be zero-dependency."
            echo "Shared code must be moved to 'internal/utils' and added as a 'devDependency'."
            exit 1
          fi
          echo "Zero-dependency constraint verified."

      - name: Check Bundle Sizes (<10KB)
        run: |
          pnpm add -g monosize # Use a tool like monosize 
          # Run the 'check-size' script defined in package.json
          turbo run check-size --filter="...[origin/main]"
3. Publishing Workflow Specification (Changesets)
This workflow manages the safe, automated, independently-versioned publishing to npm.

Developer Workflow (Local):

A developer makes changes to @cpms/core and the shared @cpms/utils.

Before committing, they run: pnpm changeset add.

The CLI prompts: "Which packages? (select @cpms/core)".

The CLI prompts: "Major, minor, or patch? (select patch)".

The CLI prompts: "Summary? (type 'Fixed bug in core logic.')".

A new file, .changeset/unique-name.md, is created.   

The developer commits this .md file along with their code changes and opens a PR.

CI/CD Publishing Workflow (GitHub Actions):

This workflow runs on push to the main branch. It is managed by the official changesets/action.

.github/workflows/release.yml

YAML
name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # We need a GITHUB_TOKEN to allow the action to create the Release PR
          token: ${{ secrets.GITHUB_TOKEN }} 

      - name: Use pnpm
        uses: pnpm/action-setup@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Create Release PR or Publish to npm
        id: changesets
        uses: changesets/action@v1
        with:
          # This command runs 'pnpm changeset version'
          # If.changeset files exist, it creates/updates a "Release PR" 
          version: pnpm changeset version

          # This command runs 'pnpm -r publish'
          # It *only* runs if the "Release PR" was merged 
          # and the commit message matches a release.
          publish: pnpm -r publish --no-git-checks
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }} # Must be set in repo secrets
V. Trade-offs and Risk Assessment
Selected Stack Trade-offs
Pro: The recommended stack (pnpm + Turborepo + tsup + Changesets) is highly flexible, uses best-in-class components, and is perfectly optimized for the project's unique zero-dependency and performance goals.

Con: This is a "disassembled" stack. The project is now responsible for maintaining the integration of four separate tools. This is a higher cognitive load than adopting an "all-in-one" framework like Nx, but this trade-off is deemed necessary to satisfy the non-negotiable zero-dependency constraint.

Versioning Strategy: Independent Versioning
The Changesets workflow has been explicitly selected to enable Independent Versioning.   

Pro: This is the correct model for public, modular libraries. @cpms/core can be stable at v2.0.0 while @cpms/data is iterating rapidly at v1.1.0. Consumers only update the protocols they need.

Con: This introduces the standard complexity of modular libraries: a consumer might use a v1.0.0 @cpms/core with a v2.0.0 @cpms/data that are incompatible.

Mitigation: This is the expected and accepted trade-off for all modular-federated systems. The alternative, Unified Versioning (where a patch to data forces a major bump to core), is unacceptable.   

Primary Risk: "Dependency Creep"
The most significant and probable risk is "Dependency Creep," where a developer, facing a deadline, attempts to pnpm add lodash to packages/core as a dependency instead of as a devDependency. This would violate the core project mandate.

Mitigation: This risk is fully mitigated by the CI Gate specified in the .github/workflows/ci.yml file. The "Check for Zero-Dependencies" step programmatically inspects all package.json files in the packages/ directory. If it finds any non-empty dependencies object, the build is immediately failed. This automated enforcement makes the zero-dependency philosophy a testable and non-negotiable part of the CI pipeline.

VI. Implementation Checklist for Mission B4.2
This checklist provides the actionable, step-by-step plan for implementing the architecture defined in this report.

1. Repository Initialization
[ ] Initialize a new git repository.

[ ] Run pnpm init at the root to create the root package.json (set to "private": true).

[ ] Create the pnpm-workspace.yaml file  and define packages: ['packages/*', 'internal/*'].   

[ ] Create the directory structure: packages/, internal/, .github/workflows/.

2. Tooling Configuration
[ ] Run pnpm add -w turbo tsup typescript @changesets/cli monosize eslint to install root-level tooling.

[ ] Create the root turbo.json file.   

[ ] Run pnpm changeset init.   

[ ] Configure .changeset/config.json (e.g., set baseBranch: "main").

[ ] Create internal/tsconfig and internal/eslint-config with base project settings.

3. Code Migration & Package Creation
[ ] Create internal/utils package, including its package.json (name: @cpms/utils).

[ ] Migrate all shared code (e.g., utils.js) into internal/utils/src/index.ts.

[ ] For each protocol (e.g., core, data):

[ ] Create the directory (e.g., packages/core).

[ ] Add the package.json file as specified in Section III.3 (with dependencies: {}).

[ ] Add the tsup.config.ts file as specified in Section III.3.

[ ] Migrate the protocol-specific source code into packages/core/src/index.ts.

[ ] Run pnpm install from the root to link all workspace:* packages.

[ ] Refactor all import statements in packages/* to use the shared util (e.g., import {... } from '@cpms/utils').

[ ] Run turbo run build to verify the entire repository builds successfully.

4. CI/CD Implementation
[ ] Add the NPM_TOKEN as a secret to the GitHub repository settings.

[ ] Commit the ci.yml (Section IV.2) to .github/workflows/ci.yml.

[ ] Commit the release.yml (Section IV.3) to .github/workflows/release.yml.

5. Validation and First Release
[ ] Test CI: Push a test branch with a change. Open a PR.

[ ] VERIFY: The ci.yml workflow runs and passes all turbo and check-size steps.

[ ] Test Zero-Dep Gate:

[ ] On the test branch, add a dependency to packages/core/package.json.

[ ] Push the change.

[ ] VERIFY: The ci.yml workflow fails at the "Check for Zero-Dependencies" step.

[ ] Revert this change.

[ ] Test Release Workflow:

[ ] Run pnpm changeset add, commit the .md file, and merge the PR to main.

[ ] VERIFY: The release.yml job runs and a "Release PR" is automatically created.   

[ ] Review and merge the "Release PR".

[ ] VERIAY: The release.yml job runs again, publishes the packages to npm.

[ ] FINAL VERIFICATION: Inspect the published package on npmjs.com and confirm its dependencies list is empty.


dev.to
Why Use NPM When PNPM Does It Better? - DEV Community
Opens in a new window

pnpm.io
pnpm vs npm
Opens in a new window

turborepo.com
Introduction | Turborepo
Opens in a new window

turborepo.com
Turborepo
Opens in a new window

wisp.blog
Nx vs Turborepo: A Comprehensive Guide to Monorepo Tools - Wisp CMS
Opens in a new window

github.com
How can include all depencies in the final index.js ? · Issue #619 · egoist/tsup - GitHub
Opens in a new window

blog.logrocket.com
Using tsup to bundle your TypeScript package - LogRocket Blog
Opens in a new window

github.com
changesets/changesets: A way to manage your versioning and changelogs with a focus on monorepos - GitHub
Opens in a new window

techblog.commercetools.com
Adopting Changesets for release and changelog automation | by Nicola Molinari
Opens in a new window

dtech.vision
Complete Guide: Publishing NPM Packages with Changesets | dTech
Opens in a new window

dev.to
Mastering Nx: The Complete Guide to Modern Monorepo Development - DEV Community
Opens in a new window

reddit.com
NX vs Turborepo? Concerned about betting on either : r/reactjs - Reddit
Opens in a new window

lerna.js.org
Lerna: Documentation
Opens in a new window

lerna.js.org
Configuration | Lerna
Opens in a new window

docs.npmjs.com
workspaces - npm Docs
Opens in a new window

github.com
pnpm vs npm – Which one should I use in real-world projects and why? #163933 - GitHub
Opens in a new window

medium.com
npm, Yarn, or pnpm in 2025: Which Package Manager Should You Choose? - Medium
Opens in a new window

pnpm.io
Workspace | pnpm
Opens in a new window

pnpm.io
Fast, disk space efficient package manager | pnpm
Opens in a new window

wisp.blog
npm vs pnpm: Which Package Manager Should You Choose? - Wisp CMS
Opens in a new window

nx.dev
Reduce Wasted Time in CI - NX Dev
Opens in a new window

nx.dev
Run Only Tasks Affected by a PR - NX Dev
Opens in a new window

nx.dev
Setting Up CI for Nx Cloud - NX Dev
Opens in a new window

turborepo.com
Constructing CI - Turborepo
Opens in a new window

stackoverflow.com
Correct turborepo filter to get "affected" workspaces on push to main - Stack Overflow
Opens in a new window

turborepo.com
Running tasks | Turborepo
Opens in a new window

lerna.js.org
Version and Publish - Lerna
Opens in a new window

nx.dev
Release Projects Independently | Nx
Opens in a new window

nx.dev
Publish in CI/CD - NX Dev
Opens in a new window

dev.to
Why we stopped using Lerna for monorepos - DEV Community
Opens in a new window

reddit.com
Changesets - a really nice alternative to Lerna for versioning packages in a monorepo
Opens in a new window

medium.com
Manage your versioning and changelogs using Changesets | by Ramu Narasinga - Medium
Opens in a new window

pnpm.io
Using Changesets with pnpm
Opens in a new window

dev.to
Publish packages from within a Monorepo - DEV Community
Opens in a new window

cuyl.github.io
Workspace | pnpm
Opens in a new window

pnpm.io
pnpm-workspace.yaml
Opens in a new window

turborepo.com
Internal Packages - Turborepo
Opens in a new window

stackoverflow.com
Creating an NPM package from a yarn workspace monorepo with internal dependency
Opens in a new window

dev.to
How to bundle a tree-shakable typescript library with tsup and publish with npm
Opens in a new window

stackoverflow.com
A fool-proof tsup config for a React component library - Stack Overflow
Opens in a new window

tanstack.com
Package Structure | TanStack Config Docs
Opens in a new window

bluepnume.medium.com
JavaScript tree shaking, like a pro | by Daniel Brain - Medium
Opens in a new window

webpack.js.org
Tree Shaking - webpack
Opens in a new window

web.dev
Reduce JavaScript payloads with tree shaking | Articles | web.dev
Opens in a new window

github.com
microsoft/monosize: Bundle size tooling for monorepos - GitHub
Opens in a new window

tweag.io
Python Monorepo: an Example. Part 1: Structure and Tooling - Tweag
Opens in a new window

dev.to
Monorepo with Bun - DEV Community
Opens in a new window

earthly.dev
Building a Monorepo with Yarn and Vite - Earthly Blog
Opens in a new window

dev.to
Complete Guide to Turborepo: From Zero to Production - DEV Community
Opens in a new window

github.com
Set up GitHub Actions caching for Turborepo - GitHub Marketplace
Opens in a new window

devblogs.microsoft.com
Streamlining Development through Monorepo with Independent Release Cycles
