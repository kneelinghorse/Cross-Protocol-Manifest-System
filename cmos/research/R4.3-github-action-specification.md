Specification for proto/validate-action@v1: A Technical Blueprint
This document provides the complete technical research, analysis, and specification for the proto/validate-action@v1 GitHub Action. It serves as the foundational blueprint for the implementation phase (Mission B4.5), covering architectural decisions, GitHub Marketplace requirements, a secure permission model, and a high-performance implementation strategy.

Part 1: proto/validate-action@v1 Technical Specification
This section details the action's core architecture, its public-facing API (inputs and outputs), and the precise implementation logic for its primary features, including marketplace publishing and versioning.

1.1 Action Architecture: A Definitive Path
The selection of an action type is the most fundamental architectural decision, dictating performance, maintainability, and compatibility. GitHub Actions supports three types: JavaScript (TypeScript), Docker, and Composite.   

Analysis of Action Types

Composite Actions: These actions are declarative wrappers that chain together existing workflow steps, primarily for reducing YAML duplication in a repository. They are unsuitable for this project's requirements, as they cannot execute complex custom logic, possess known limitations (such as an inability to use post steps for cleanup ), and have a clumsy model for handling secrets. The proto/validate-action requires complex API calls, file system globbing, and external process execution, all of which are beyond the scope of a composite action.   

Docker Actions: Docker container actions provide a fully encapsulated environment, which is ideal for language-agnostic tools or dependencies on a specific operating system and its libraries. However, this benefit comes at a significant performance cost. Each execution of the action suffers from cold-start latency as the runner must pull the Docker image. This latency directly contravenes the constraint for a fast runtime (<5 minutes). Furthermore, Docker actions can only run on Linux runners, limiting compatibility for users who may be on Windows or macOS-based self-hosted runners.   

TypeScript (JavaScript) Actions: These actions run as a Node.js process directly on the runner virtual machine. This architecture provides the fastest possible startup time and is cross-compatible with all GitHub-hosted runner environments (Linux, macOS, Windows). Critically, this choice grants full access to the official GitHub Actions toolkit (@actions/core, @actions/github, @actions/glob, @actions/tool-cache), which are the standard, supported libraries for building robust, high-performance actions.   

The Decoupled Architecture and the proto CLI

The primary constraint for this action is its dependency on the existing proto CLI.

A Docker-based approach would bundle the proto CLI binary within the container image. This creates a tight, inflexible coupling. If the proto CLI is updated with a critical bugfix (e.g., v1.0.1), the entire GitHub Action would need to be rebuilt, re-tagged, and re-released (as v1.0.1) simply to ship the new binary.

A TypeScript-based approach enables a decoupled architecture. The action's TypeScript code will not bundle the CLI. Instead, it will download the proto CLI at runtime. This allows the action's logic (validation, commenting) to be versioned independently of the tool it wraps.

This decoupled model is the professional standard used by all official actions/setup-* actions (e.g., actions/setup-node). It provides maximum flexibility by allowing the action to expose an input (e.g., proto-cli-version) for the user, who can then choose to pin the CLI version or use latest without waiting for a new action release.

Decision: TypeScript Action

The proto/validate-action will be a TypeScript Action. This decision is based on its superior performance, cross-platform compatibility, and the adoption of a decoupled architecture that enhances long-term maintainability.

The following table summarizes this architectural decision:

Table 1: Action Architecture Decision Matrix

Feature	TypeScript Action	Docker Action	Composite Action
Startup Performance	
Excellent (Fastest). Runs as a native Node.js process.

Poor (Slow). Requires Docker image pull on cold starts.

Excellent (Fastest). Declarative YAML execution.
OS Compatibility	
Excellent. Runs on Linux, macOS, and Windows runners.

Poor. Limited to Linux runners only.

Excellent. Runs on Linux, macOS, and Windows.
Complex Logic	Excellent. Full power of Node.js and npm ecosystem.	Excellent. Full power of any language in the container.	
Poor. Cannot execute custom code; limited to orchestrating steps.

GitHub API Integration	
Excellent. Native integration via @actions/github.

Good. Possible via API calls, but less integrated.	Poor. Must use pre-built actions for API calls.
External CLI Handling	
Excellent (Decoupled). Fetches and caches CLI at runtime via @actions/tool-cache.

Poor (Coupled). Bundles CLI, requiring action release for CLI updates.	N/A. Cannot manage external dependencies.
Maintainability	Excellent. CLI version is independent of action version.	Poor. Action version is tied directly to bundled CLI version.	N/A.
  
1.2 Marketplace Publishing and Versioning Strategy
To be published on the GitHub Marketplace, the action must adhere to several requirements and adopt a robust versioning strategy.

Marketplace Requirements

The proto/validate-action repository must be public. The repository itself must not contain any workflow files at its root; they must be in the .github/workflows directory.   

The action.yml metadata file must contain:

Unique Name: The name in action.yml must be globally unique within the Marketplace.   

Branding: A branding block is required for the action's Marketplace page. This consists of an icon (selected from the Feather icon set, e.g., shield) and a color (e.g., purple). GitHub's own logos and trademarks are forbidden.   

Documentation: A comprehensive README.md file is the most critical component for user adoption. It must include:

A clear description of the action.

A complete list of all inputs and outputs.

Usage examples for common scenarios (e.g., PR validation, push-to-main).

The full permissions block required by the action.

License: A LICENSE file (e.g., MIT or Apache 2.0) is mandatory.

Since the action will be published for free, the requirements for paid apps, such as minimum installation counts and billing event handling, do not apply.   

Action Versioning Strategy

A well-defined versioning strategy is a security and maintenance contract with the action's users. The implementation will follow Semantic Versioning (SemVer).   

Immutable Releases: Every new release of the action will be published with an immutable, full SemVer Git tag (e.g., v1.0.0, v1.0.1, v1.1.0). Security-conscious organizations will be instructed to pin their workflows to these full tags (e.g., uses: proto/validate-action@v1.0.0). This practice guarantees stability and prevents a new, potentially breaking version from being adopted accidentally.   

Floating Major Version: A "floating" Git tag (e.g., v1) will also be maintained. This tag will be a pointer, which will be forcibly moved to the commit SHA of the latest v1.x.x release.

Most users will follow the common convention of using the major version tag (e.g., uses: proto/validate-action@v1). This strategy provides them with the best of both worlds: they are protected from breaking changes in a future v2 release, but they automatically receive non-breaking bug fixes and critical security patches as soon as they are published.   

This implies that the project's own release automation process must include a step to update and push the v1 tag (e.g., git tag -f v1 v1.0.1 && git push -f origin v1) as part of publishing a new patch or minor release.

1.3 Action Input and Output Schema (action.yml)
The action.yml file defines the action's public API. All inputs will be read using the core.getInput() function from the @actions/core library , which automatically retrieves values from the with: block in the user's workflow.   

Table 2: Input Schema Specification (action.yml)

Input ID	Description	Required	Default
manifest-glob	A glob pattern, or newline-separated list of patterns, for manifest files to validate.	true	**/*.proto.json
fail-on-breaking	Fail the workflow step if breaking changes are detected between the PR and the base branch.	false	true
fail-on-warnings	Fail the workflow step if any validation warnings are found. Errors will always fail the step.	false	false
comment-on-pr	Post or update a "sticky" summary comment on the associated pull request.	false	true
comment-on-pr-sentinel	A unique HTML comment string used to identify the action's "sticky" comment for updates.	false	``
compare-branch	The name of the base branch to compare against for breaking changes (e.g., main). If unset, it will be auto-detected from the pull request payload.	false	(auto-detect)
output-format	The format for detailed reporting. github-annotations (default) creates inline code annotations. json outputs a report file.	false	github-annotations
proto-cli-version	The version of the proto CLI to download and use (e.g., v1.2.3, latest).	false	latest
github-token	The GITHUB_TOKEN used to call the GitHub API for commenting, fetching content, and posting annotations.	true	${{ secrets.GITHUB_TOKEN }}
Table 3: Output Schema Specification (action.yml)

Output ID	Description
validated-count	The total number of manifest files found and validated.
passed-count	The total number of manifests that passed validation.
failed-count	The total number of manifests that failed validation.
breaking-changes-count	The total number of breaking changes detected.
validation-report-json	A minified JSON string of the full validation report. Useful for passing to other actions.
Output Implementation Protocol

The implementation must use the core.setOutput('name', 'value') function from the @actions/core library. The older ::set-output workflow command has been deprecated in favor of writing to an environment file, $GITHUB_OUTPUT. The core.setOutput() function provides a stable abstraction layer, ensuring the action will not break if GitHub modifies this underlying protocol in the future.   

1.4 Core Implementation Blueprint: Breaking Change Detection
The action's most complex feature is detecting breaking changes, which requires comparing the state of manifest files in the pull request's HEAD branch against their state in the BASE branch (e.g., main).

Rejected Implementation Strategies

Dual actions/checkout: This pattern involves checking out the HEAD branch, then checking out the BASE branch into a subdirectory. This is slow, pollutes the runner filesystem, and is complex to manage.   

Full Git History (fetch-depth: 0): This pattern involves checking out the HEAD branch with full history (fetch-depth: 0)  and then using git diff commands  to compare the two commits. This is extremely slow (fetches all repository history) and requires brittle parsing of git diff output.   

Specified Implementation: The API-Driven Diff

The optimal strategy is an API-driven approach that is performant, robust, and secure. It bypasses the need for complex git operations entirely.

The algorithm will be as follows:

Checkout HEAD: The user's workflow will check out the PR's HEAD commit using actions/checkout@v4. This is the default and is very fast, as it typically fetches only a single commit (fetch-depth: 1).   

Get Base SHA: The action, running in the pull_request or pull_request_target context, will retrieve the SHA of the base branch from the event payload: github.context.payload.pull_request.base.sha.   

Instantiate Client: The action will use the github-token input to create an authenticated Octokit client instance via @actions/github.

Glob Local Files: The action will use the @actions/glob library to find all manifest files in the local (HEAD) checkout based on the manifest-glob input.

Iterate and Compare: The action will loop through each manifest file found:

Get HEAD Content: For a file (e.g., data/users.proto.json), it reads the content from the local filesystem (content_head).

Get BASE Content: It then calls the GitHub REST API: github.rest.repos.getContent({ owner, repo, path: 'data/users.proto.json', ref: base_sha }).   

Handle File State:

If the API returns a 404 Not Found response, the file is new in the PR and can be skipped for diffing.

If the API returns a 200 OK, it will Base64-decode the content field from the response  to get the content_base string.   

Execute Diff: The action will pass both content_head and content_base to the proto CLI's diff() function.

Aggregate Results: The action will collect all validation and diff results.

This API-driven strategy is superior because it treats the GitHub repository as a key-value store, where the key is (file_path, ref) and the value is file_content. It fetches only the bytes it needs, resulting in a minimal, fast, and highly reliable implementation that avoids the complexities of managing Git history on the runner.   

Part 2: Interaction and Reporting Strategy
A CI/CD tool is only effective if it communicates its findings to the developer in a way that is timely, discoverable, and actionable. A simple pass/fail is insufficient, but overly verbose reports in the wrong place are perceived as "spam"  and may be ignored.   

2.1 A Hybrid, Three-Tiered Reporting Model
This specification defines a three-tiered reporting model to solve the "discoverability vs. spam" conflict, providing the right level of detail in the right location.

Tier 1: Inline Code Annotations (Highest Immediacy)

Mechanism: The action's TypeScript code will use the @actions/core toolkit, specifically the core.error(), core.warning(), and core.notice() functions.   

Behavior: These functions are wrappers for workflow commands that GitHub natively understands. When the action finds an error, it will issue a command with file and line-number metadata. For example: core.error('PII field missing governance policy', { file: 'data/users.proto.json', startLine: 45, title: 'PII Violation' }).   

User Experience: This creates an annotation directly within the pull request's "Files changed" tab. The developer sees a red "X" by the file and a comment on the exact line of code they modified. This is the tightest and most effective feedback loop, as seen in popular linting actions.   

Tier 2: The Job Summary (Maximum Detail)

Mechanism: The action will use the core.summary API (@actions/core.summary), which writes to the $GITHUB_STEP_SUMMARY environment file.   

Behavior: This API builds a rich, persistent Markdown report that is attached to the workflow run in the "Actions" tab. The action will write its full and unabridged report here. This includes summary tables , code blocks showing detailed diffs for breaking changes, and complete lists of all errors, warnings, and PII violations.   

User Experience: This is the "source of truth" for the validation run. It supports GitHub Flavored Markdown, allowing for tables, links, and collapsible sections.   

Constraint: This summary has a 1MB (1024k) size limit. The implementation must truncate the report if it exceeds this limit, providing a message that the report was truncated.   

Tier 3: The Pull Request Comment (Maximum Discoverability)

Mechanism: If comment-on-pr: true, the action will use its @actions/github Octokit client to post a comment on the pull request.   

Behavior: This comment will not contain the full report. Doing so is "spammy" , risks being truncated by GitHub's own comment limits , and buries other human conversation. Instead, the PR comment will be a brief summary and a direct link to the Tier 2 Job Summary.   

User Experience: The developer receives a notification and sees a comment in the PR's main conversation timeline. This solves the "poor discoverability" of the Job Summary. The comment acts as a highly discoverable notification that navigates the user to the detailed report.   

This hybrid model leverages the strengths of all three reporting surfaces, providing high-immediacy feedback (Annotations), high-detail (Job Summary), and high-discoverability (PR Comment).

2.2 PR Commenting: Implementation and Templates
To avoid "spamming" the pull request with a new comment on every push , the action must implement a "sticky" comment strategy.   

"Sticky" Comment Implementation

The action will not use a third-party commenting action. This logic will be implemented directly using the @actions/github client.   

Define Sentinel: The action will use a unique, hidden HTML comment (the "sentinel") to identify its comments. The default will be ``, configurable via the comment-on-pr-sentinel input.

Find Comment: On execution, the action will call github.rest.issues.listComments for the current PR (github.context.issue.number).

Iterate: It will search the body of each comment for the sentinel string.

Update or Create:

If found: The action retrieves the comment.id of the existing comment and calls github.rest.issues.updateComment to overwrite its content with the new report summary.

If not found: The action calls github.rest.issues.createComment, ensuring the new comment body includes the sentinel for future updates.

Comment Template Designs

The templates must be brief, clear, and use the <details> HTML tag to hide any lists, preventing the summary from dominating the PR timeline.   

Deliverable: Template 1 (Validation Failed)

ðŸ” Proto Manifest Validation: âŒ Failed
Status: Found 1 breaking change and 2 errors in 12 manifests.

Breaking Changes (1)
event/payment.proto.json: Removed required field transaction_id.

Errors (2)
data/users.proto.json: PII field social_security_number missing required governance policy.

data/users.proto.json: Field user_location has invalid type.

(https://github.com/org/repo/actions/runs/12345) (This link will be dynamically generated)

Deliverable: Template 2 (Validation Succeeded)

ðŸ” Proto Manifest Validation: âœ… Passed
All 12 manifest files passed validation. No breaking changes detected.

**

3.1 The pull_request vs. pull_request_target Security Model
This is the most critical security decision for the action.

The Dilemma

The action must post comments on pull requests.

When a pull request comes from a fork, the standard on: pull_request trigger is used.

For security, GitHub provides this workflow with a read-only GITHUB_TOKEN and no access to repository secrets.   

A read-only token cannot be used to post comments, as this is a write operation.   

The on: pull_request_target trigger was created to solve this. It runs in the context of the base repository, so it is granted a read/write token and access to secrets, even for forks.   

The Vulnerability The pull_request_target trigger is dangerous. It runs the workflow file as it exists in the base branch (e.g., main). If this trusted workflow also checks out the PR's head branch (ref: ${{ github.event.pull_request.head.sha }})  and then executes arbitrary code from it (e.g., npm install && npm test on the PR's package.json), an attacker can gain code execution with access to repository secrets.   

The "Safe pull_request_target Pattern": This Specification

This action requires pull_request_target to fulfill its commenting requirements for public/forked repositories. This risk will be mitigated by adopting a specific, safe usage pattern.

Trusted Workflow: The user's workflow file (e.g., .github/workflows/validate.yml) runs from the main branch (the target) and is therefore trusted code.

Untrusted Data: This workflow must use actions/checkout@v4 with ref: ${{ github.event.pull_request.head.sha }}. This places the untrusted code from the PR onto the runner's filesystem.   

Trusted Tool: The workflow then calls uses: proto/validate-action@v1. Our action, which is also trusted code (as it's defined by the v1 tag), then executes.

Safe Operation: Our action reads the untrusted files (*.proto.json) as data. It passes this data to the proto CLI (also trusted code).

The Rule: The workflow must not execute any other code from the untrusted checkout. The vulnerability is not in checking out the code; it is in executing it. Our action only reads it.

This "trusted tool, untrusted data" model isolates the action from the "pwn request" vulnerability. The action's documentation must explicitly provide the safe workflow example and warn users not to run commands like npm install from the PR's code in the same job.

3.2 Least Privilege GITHUB_TOKEN Configuration
The principle of least privilege must be enforced. The GITHUB_TOKEN should, by default, have read-only permissions , and the workflow file must explicitly request the minimal write permissions required for its job.   

The user's workflow file must include the following permissions block at the job or workflow level:yaml permissions:

REQUIRED: To fetch repository content (e.g., actions/checkout, or our API-driven diff).
contents: read

REQUIRED: To create inline code annotations (Tier 1 Reporting).
checks: write

REQUIRED: To post and update PR comments (Tier 3 Reporting).
pull-requests: write


**Permission Rationale:**
*   `contents: read`: Required by `actions/checkout` to read the repository code. Also required by our API-driven diff logic to call `repos.getContent`.[67]
*   `checks: write`: This permission is required to create GitHub Checks and post annotations, which is the mechanism underpinning `core.error()`.[40, 41]
*   `pull-requests: write`: This permission is required to post and update comments on the pull request.[53, 68, 69] While `issues: write` [69] also works (as PRs are a type of issue), `pull-requests: write` is more specific and thus preferred.

### 3.3 Input and Dependency Hardening

**Input Sanitization**
*   **Threat:** The `manifest-glob` input is a potential vector for command injection. An attacker could set `manifest-glob: '**/*; rm -rf /'`.[70, 71] If the action's code implements globbing by passing this string to a shell (`exec('ls ' + globInput)`), it would create a severe vulnerability.
*   **Specification:** The implementation *must not* pass user-provided inputs to a shell.
*   **Mitigation:** The action *must* use the `@actions/glob` library from the official toolkit. This library is a JavaScript globber that treats the input pattern as *data*, not an executable command. It is not vulnerable to shell injection.[72]

**Dependency Hardening**
*   **Threat:** The action itself depends on third-party `npm` packages and other GitHub Actions (like `actions/checkout`). If these dependencies are compromised (a supply-chain attack), the action becomes a vector.
*   **Specification:**
    1.  All `npm` dependencies in `package.json` must be pinned to exact versions.
    2.  All `uses:` statements in the action's *own* internal workflows (for testing, releasing, etc.) must be pinned to full immutable SemVer tags or, preferably, to a commit SHA.[23]
    3.  The action's documentation will encourage security-conscious users to pin to a full SemVer tag (e.g., `proto/validate-action@v1.0.0`) for maximum security.

## Part 4: Testing and Performance Strategy

A CI/CD action must be both correct and fast. An unreliable or slow tool will be bypassed or disabled by developers, defeating its purpose.

### 4.1 Comprehensive Testing Checklist

A three-tiered testing strategy is required to ensure correctness and robustness.

**Deliverable: Testing and Validation Checklist**

**1. Unit Tests (via Jest)**
*   **Goal:** Test individual TypeScript functions in isolation.
*   **Mechanism:** Use the Jest testing framework.
*   **Key Requirement:** The implementation *must* mock the `@actions/` toolkit libraries. This includes mocking `core.getInput` to provide mock inputs, `core.setOutput` to capture outputs, and the `github` context and Octokit client (`@actions/github`).[10, 24, 73]
*   **Test Scenarios:**
    *   Input parsing (e.g., `fail-on-breaking: 'false'` is correctly parsed as a boolean).
    *   The `listComments`/`updateComment`/`createComment` logic for the "sticky" comment.
    *   Report generation logic (e.g., summary table creation).
    *   The API-driven diff logic (mocking `fs.readFile` and `github.rest.repos.getContent`).

**2. Integration Tests (via `nektos/act`)**
*   **Goal:** Test the *compiled* action in a simulated GitHub Actions environment locally.
*   **Mechanism:** Use the `nektos/act` CLI tool.[74, 75, 76] This tool reads the `action.yml` file and uses Docker to run the action, emulating the GitHub environment. This provides fast feedback during development without requiring a `git push`.[75] The `act-js` library can be used to programmatically run these tests in CI.[77]
*   **Test Scenarios:**
    *   Run `act pull_request` with a sample event JSON payload.
    *   Test against a fixture repository with only passing manifests.
    *   Test against a fixture repository with failing manifests (asserting the action fails).
    *   Test against a fixture repository with known breaking changes.

**3. End-to-End (E2E) Tests (Live GitHub)**
*   **Goal:** Test the action in the *real* GitHub Actions environment, verifying all API integrations.[78, 79]
*   **Mechanism:** The `proto/validate-action` repository itself will use "dogfooding".[80] It will contain a workflow file (e.g., `.github/workflows/e2e-test.yml`) that triggers `on: pull_request`.
*   **Test Scenarios:**
    *   This workflow will check out the PR's code.
    *   It will run the action *against itself*, targeting a directory of test fixtures (e.g., `/fixtures/passing`, `/fixtures/failing`).
    *   The test will *assert* that the action correctly *fails* when run against the failing fixtures.
    *   The test will verify that a PR comment is *actually* posted and updated, and that annotations are created, providing a full, closed-loop validation of all three reporting tiers.

### 4.2 Performance Optimization: A Dual-Cache Strategy

Slowdowns in GitHub Actions are most commonly caused by re-installing dependencies or re-downloading tools on every run.[81, 82] This action has *two* distinct sets of dependencies that must be cached using *two* different mechanisms.

**Cache 1: Action Dependencies (via `actions/cache`)**
*   **What:** The action's own `node_modules` directory, required by its compiled JavaScript.
*   **Mechanism:** The *user's workflow* will be instructed to use the official `actions/cache` action.[81, 83]
*   **Key:** The cache key will be based on the operating system and a hash of the action's `package-lock.json` file (e.g., `${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}`).[81, 84] This ensures the cache is invalidated only when dependencies change.

**Cache 2: External Tool (via `@actions/tool-cache`)**
*   **What:** The `proto` CLI binary that the action downloads.
*   **Mechanism:** The action's *own TypeScript code* will use the `@actions/tool-cache` npm package.[11, 85]
*   **Process:** This library is the standard, robust solution for `setup-` style actions. The implementation will:
    1.  Call `tc.find('proto', version)` to check if the tool is already in the cache.
    2.  If not found, call `tc.downloadTool(url)` to fetch the binary.
    3.  Call `tc.extractTar(path)` or `tc.extractZip(path)` to unpack the tool.
    4.  Call `tc.cacheDir(extractedPath, 'proto', version)` to add the tool to the cache.
    5.  Call `tc.addPath(toolDir)` to add the tool's binary to the `PATH` for the rest of the job.
This is a more robust solution than using `actions/cache` for binaries, as it is a purpose-built SDK that manages the tool's availability, caching, and `PATH` injection.

### 4.3 Performance Optimization: Enterprise-Scale Parallelization

While the action itself will validate files serially, a monorepo with thousands of manifests could exceed the 5-minute runtime target. The action will not implement internal parallelization; instead, the documentation will specify the standard "Dynamic Matrix Pattern" for users to parallelize validation at the *job* level.

**Dynamic Matrix Pattern** [86]
This pattern leverages GitHub's native job parallelization.[23, 87, 88]

1.  **Job 1: `discover-manifests`:** A preliminary job in the user's workflow will run a script to find all manifest *directories* (e.g., `['svc1', 'svc2', 'svc3']`) and package them into a single-line JSON array, which it sets as a job output.[86]
2.  **Job 2: `validate-manifests`:** This job will `need: discover-manifests` and use a dynamic `strategy.matrix`:
    ```yaml
    jobs:
      discover:
        runs-on: ubuntu-latest
        outputs:
          dirs: ${{ steps.find-dirs.outputs.dirs_json }}
        steps:
          - id: find-dirs
            #... script to find dirs and output JSON...
            run: echo 'dirs_json=["svc1","svc2","svc3"]' >> $GITHUB_OUTPUT

      validate:
        needs: discover
        runs-on: ubuntu-latest
        strategy:
          fail-fast: false
          matrix:
            # Dynamically create one job per directory
            dir: ${{ fromJson(needs.discover.outputs.dirs) }}
        steps:
          - uses: actions/checkout@v4
          - uses: proto/validate-action@v1
            with:
              # Each job validates one directory
              manifest-glob: '${{ matrix.dir }}/**/*.proto.json'
              comment-on-pr: false # Disable commenting for parallel runs
    ```
By documenting this enterprise-grade pattern, the action provides a clear path to high performance at scale, offloading the complexity of parallelization to the GitHub Actions platform itself.

## Conclusions and Final Specification

This research and analysis concludes with a definitive technical specification for `proto/validate-action@v1`.

1.  **Architecture:** The action **must** be a **TypeScript Action** to ensure high performance and enable a maintainable, decoupled architecture for managing the `proto` CLI.
2.  **Core Logic:** Breaking change detection **must** be implemented using the **API-Driven Diff** strategy (checking out HEAD, fetching BASE content via the `repos.getContent` REST API), as this is more performant and robust than `git diff` or dual-checkout strategies.
3.  **Reporting:** The action **must** implement the **Three-Tiered Reporting Model** (Inline Annotations, Job Summary, and PR Comment-as-Notification) to provide feedback that is simultaneous, detailed, and discoverable.
4.  **Security:** The action's documentation **must** specify the **"Safe `pull_request_target` Pattern"** as the required security model to enable commenting on fork PRs. The implementation **must** sanitize the `manifest-glob` input by using the `@actions/glob` library. The user's workflow **must** specify the minimal `permissions` block (`contents: read`, `checks: write`, `pull-requests: write`).
5.  **Performance:** The action **must** implement a **Dual-Cache Strategy**, using `actions/cache` for its own `node_modules` and the `@actions/tool-cache` SDK to manage the `proto` CLI binary. The **Dynamic Matrix Pattern** will be the documented solution for enterprise-scale parallelization.

This specification provides a complete and secure blueprint for the implementation phase.

docs.github.com
About custom actions - GitHub Docs
Opens in a new window

docs.github.com
Creating a composite action - GitHub Docs
Opens in a new window

dev.to
GitHub Actions Composite vs Reusable Workflows - DEV Community
Opens in a new window

kavyagoudam.medium.com
GitHub Composite Actions: A Practical Guide to Reusable Workflow Components.
Opens in a new window

thinairlabs.ca
Solving Post Step Issues in GitHub Composite Actions - Thin Air Labs
Opens in a new window

stackoverflow.com
Using Secrets in Composite Actions GitHub - Stack Overflow
Opens in a new window

medium.com
Automating Workflows: Harnessing GitHub Actions, Docker, and GitHub npm Package | by Sergey Dudik | Medium
Opens in a new window

medium.com
How to get started with your first JavaScript/TypeScript GitHub Action | by Templum
Opens in a new window

stackoverflow.com
Update GitHub Action from set-output to GITHUB_OUTPUT - Stack Overflow
Opens in a new window

dev.to
Write Unit Test for your Typescript GitHub Action - DEV Community
Opens in a new window

kenmuse.com
Building GitHub Actions Runner Images With A Tool Cache - Ken Muse
Opens in a new window

docs.github.com
About GitHub Marketplace for apps
Opens in a new window

docs.github.com
Creating and publishing actions - GitHub Docs
Opens in a new window

docs.github.com
Publishing actions in GitHub Marketplace
Opens in a new window

hackernoon.com
Building & Publishing Your Own Custom GitHub Action in Marketplace | HackerNoon
Opens in a new window

github.com
Add icon and color to action.yml Â· Issue #27 - GitHub
Opens in a new window

github.com
GitHub Logos and Usage
Opens in a new window

docs.github.com
Requirements for listing an app - GitHub Marketplace
Opens in a new window

aws.amazon.com
Using Semantic Versioning to Simplify Release Management | AWS DevOps & Developer Productivity Blog
Opens in a new window

docs.github.com
Secure use reference - GitHub Docs
Opens in a new window

blog.gitguardian.com
GitHub Actions Security Best Practices [cheat sheet included] - GitGuardian Blog
Opens in a new window

github.com
actions/checkout: Action for checking out a repo - GitHub
Opens in a new window

docs.github.com
Workflow syntax for GitHub Actions
Opens in a new window

stackoverflow.com
How to test custom JavaScript Github actions? - Stack Overflow
Opens in a new window

dev.to
Github Actions - Output - DEV Community
Opens in a new window

samanpavel.medium.com
GitHub Actions â€” Output Parameters | by Pavel Saman - Medium
Opens in a new window

github.com
Diff between PR and master Â· Issue #160 Â· actions/checkout - GitHub
Opens in a new window

github.com
Optimise fetching all commits in a pull request Â· Issue #416 Â· actions/checkout - GitHub
Opens in a new window

stackoverflow.com
How to run git diff in github actions - Stack Overflow
Opens in a new window

github.com
git-diff-action - GitHub Marketplace
Opens in a new window

stackoverflow.com
How to compare files from two different branches - Stack Overflow
Opens in a new window

stackoverflow.com
Getting base branch SHA on pull request in Github Action Workflow - Stack Overflow
Opens in a new window

docs.github.com
REST API endpoints for repository contents - GitHub Docs
Opens in a new window

stackoverflow.com
github api v3 to fetch contents of a file from a particular branch other than master
Opens in a new window

stackoverflow.com
How to get a file from specific commit hash using GitHub APIs? - Stack Overflow
Opens in a new window

community.sonarsource.com
Github Action PR edit comment instead of create comment - Sonar Community
Opens in a new window

notes.kodekloud.com
Troubleshooting JavaScript Actions using Workflow Commands - KodeKloud Notes
Opens in a new window

docs.github.com
Workflow commands for GitHub Actions
Opens in a new window

github.com
Actions Â· GitHub Marketplace - Annotate check scripts output
Opens in a new window

github.com
Actions Â· GitHub Marketplace - Test Reporter
Opens in a new window

github.com
Lint Action - GitHub Marketplace
Opens in a new window

github.blog
Supercharging GitHub Actions with Job Summaries
Opens in a new window

github.com
Test Summary Action - GitHub Marketplace
Opens in a new window

github.com
Show a helpful summary of test results in GitHub Actions CI/CD workflow runs
Opens in a new window

github.com
[BUG] unable to upload summary: upload aborted, supports content up to a size of 1024k, got 1028k Â· Issue #867 Â· actions/dependency-review-action - GitHub
Opens in a new window

github.com
Job Summary Size Limitation aborts the job Â· Issue #774 Â· actions/dependency-review-action
Opens in a new window

stackoverflow.com
Commenting a pull request in a GitHub action - Stack Overflow
Opens in a new window

stackoverflow.com
Truncate github comments, output to github commit comment first 20 errors only
Opens in a new window

github.com
Job summary on PR Â· Issue #1058 Â· cypress-io/github-action
Opens in a new window

ecanarys.com
Supercharging GitHub Actions with Job Summaries and Pull Request comments - Canarys
Opens in a new window

github.com
Display job summaries in PR checks view Â· community Â· Discussion #16451 - GitHub
Opens in a new window

stackoverflow.com
Github Action: update existing comment if one exist or create a new comment
Opens in a new window

github.com
Add PR Comment Â· Actions Â· GitHub Marketplace
Opens in a new window

github.com
Create or Update Comment Â· Actions Â· GitHub Marketplace
Opens in a new window

github.com
Excessively long pull request descriptions are not being truncated Â· Issue #8900 - GitHub
Opens in a new window

github.com
Truncation of Resolved Comments during Pull Request Code Review #16111 - GitHub
Opens in a new window

securitylab.github.com
Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests
Opens in a new window

docs.github.com
Events that trigger workflows - GitHub Docs
Opens in a new window

docs.github.com
Managing GitHub Actions settings for a repository - GitHub Docs
Opens in a new window

github.com
Actions Â· GitHub Marketplace - Comment Pull Request
Opens in a new window

github.com
Clarify why this needs pull_request_target, rather than `pull_request` Â· Issue #121 Â· actions/labeler - GitHub
Opens in a new window

stackoverflow.com
Permission to repo denied to github-actions for PR coming from a Fork only - Stack Overflow
Opens in a new window

runs-on.com
Pull Request vs Pull Request Target trigger - RunsOn
Opens in a new window

dev.to
Secure GitHub Actions by pull_request_target - DEV Community
Opens in a new window

github.com
Checking out a merge commit in `pull_request_target` workflows Â· Issue #518 Â· actions/checkout - GitHub
Opens in a new window

stepsecurity.io
7 GitHub Actions Security Best Practices (With Checklist) - StepSecurity
Opens in a new window

docs.github.com
REST API endpoints for pull requests - GitHub Docs
Opens in a new window

github.com
Actions Â· GitHub Marketplace - Powerful pull request comment
Opens in a new window

github.com
Permissions nesecary to comment on a PR Â· community Â· Discussion #26644 - GitHub
Opens in a new window

securitylab.github.com
Keeping your GitHub Actions and workflows secure Part 2: Untrusted input
Opens in a new window

synacktiv.com
GitHub Actions exploitation: untrusted input - Synacktiv
Opens in a new window

wiz.io
Hardening GitHub Actions: Lessons from Recent Attacks | Wiz Blog
Opens in a new window

github.com
Mocking @actions/github in your tests Â· Issue #71 Â· actions/toolkit
Opens in a new window

freecodecamp.org
How to Run GitHub Actions Locally Using the act CLI Tool - freeCodeCamp
Opens in a new window

github.com
nektos/act: Run your GitHub Actions locally
Opens in a new window

medium.com
Running GitHub Actions Locally with Act | by Timothy | HostSpace Cloud Solutions
Opens in a new window

redhat.com
Testing Github actions locally - Red Hat
Opens in a new window

hub.qovery.com
Build E2E Testing Ephemeral Environments with GitHub Actions and Qovery
Opens in a new window

medium.com
Running end-to-end tests with GitHub Actions | by Warren Day | tomorrowapp | Medium
Opens in a new window

medium.com
Reusable Github Action Workflows II: Integration Testing | by BaÅŸak TuÄŸÃ§e Eskili - Medium
Opens in a new window

medium.com
GitHub Actions Caching and Performance Optimization | by Amaresh Pelleti - Medium
Opens in a new window

dev.to
Optimizing GitHub Actions Performance: Enhance Workflows with Caching
Opens in a new window

github.com
Cache dependencies and build outputs in GitHub Actions
Opens in a new window

runs-on.com
Using caching to speed up GitHub Actions workflows - RunsOn
Opens in a new window

github.com
Actions Â· GitHub Marketplace - Tool Cache
Opens in a new window

stackoverflow.com
How to github action parallelize tests dynamically by folder? - Stack Overflow
Opens in a new window

docs.github.com
Running variations of jobs in a workflow - GitHub Docs
Opens in a new window

medium.com
Running Parallel Jobs in GitHub Actions | by Mohammad Anwar Siddiqui - Medium
Opens in a new window
